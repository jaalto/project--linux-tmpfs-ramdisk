#!/bin/sh
#
#   Copyright
#
#       Copyright (C) 2018-2019 Jari Aalto
#
#   License
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program. If not, see <http://www.gnu.org/licenses/>.
#
#  DESCRIPTION
#
#       Manages selected direcories in tmpfs RAM:
#
#       - start - Set up ramdisk and copy data from real disk.
#       - stop -  Teardown ramdisk and write data from RAM to disk
#       - flush - Write data from RAM to disk. This is not ATOMIC
#                 operation. Some loss is inevitable if server is busy
#                 because the "bind" mounts need to be releases during
#                 the copy operations.
#
#       See also https://wiki.debian.org/ZRam
#
#   NOTES
#
#       For debugging, active dry run mode by seting variable "test".
#       Set variable "verbose" to display rsync(1) transfers.
#
#           [verbose=1] [test=1] /<path>/ramdisk <command>

### BEGIN INIT INFO
# Provides:          ramdisk
# Required-Start:    $local_fs
# Required-Stop:     $local_fs
# Default-Start:     S
# Default-Stop:      0 1 6
# Short-Description: Manage directories moved to tmpfs
# Description:       Manage directories moved to tmpfs
### END INIT INFO

PATH=/bin:/usr/bin:/sbin:/usr/sbin

. /lib/lsb/init-functions

# Local variables

VERBOSE="--quiet"

if [ "$verbose" ]; then
    VERBOSE="--verbose"
fi

BIN=$(basename $0)
BIN=${BIN%.sh}
CONF=/etc/default/ramdisk
RSYNCOPT="-a --recursive --links --owner --group $VERBOSE"
RSYNC="nice --adjustment=${NICE:--20} rsync $RSYNCOPT"

# Default configuration variables unless overriden in $CONF

NICE=-20  # make rsync(1) as fast as posisble

RAMDISK=/mnt/ramdisk

DIRLIST="\
/var/cache/man \
/var/tmp \
/tmp\
"

test -r $CONF && . $CONF

LOCK=$RAMDISK/ramdisk.lock

Warn ()
{
    echo "$*" >&2
}

Run ()
{
    ${test:+echo} "$@"
}

IsOverlayfs ()
{
    grep -q overlay /proc/filesystems
}

IsMountOverlay ()
{
    mount | egrep " $1 +type +\<overlay "
}

IsMountRamdiskRoot ()
{
    mount | egrep -q " $RAMDISK +type +\<tmpfs "
}

Mount ()
{
    local src=$1
    local dest=$2

    if [ ! "$2" ]; then
        Warn "$BIN: (Mount) arguments missing"
        return 1
    fi

    if [ ! -d "$src" ]; then
        Warn "$BIN: ERROR no src $src"
        return 0
    fi

    if mount | grep --quiet $dest.overlay ; then
        return 0  # Already
    fi

    Run mkdir -p $dest $dest.workdir $dest.overlay

    # Special permissions

    case "$src" in
        /tmp)
            chmod a=rwx,o+t $dest
            ;;
    esac

    Run $RSYNC --delete $src/ $dest/

    Run mount -t overlay \
        -o rw,lowerdir=$src,upperdir=$dest.overlay,workdir=$dest.workdir \
        none $dest.overlay

    Run mount -o bind $dest.overlay $src
}

Umount ()
{
    local src=$1
    local dest=$2
    local type=$3

    if [ ! "$2" ]; then
        Warn "$BIN: (Umount) arguments missing"
        return 1
    fi

    if [ ! -d "$dest.overlay" ]; then
        return 0
    fi

    if [ ! -d "$src" ]; then
        Warn "$BIN: ERROR no src $src"
        return 0
    fi

    if [ ! -d "$dest" ]; then
        Warn "$BIN: ERROR no dest $dest"
        return 0
    fi

    if ! mount | grep --quiet $dest.overlay ; then
        return 0  # No overlay mount
    fi

    if [ "$type" = "flush" ]; then
        # Open up bind mount and flush chnages back
        Run umount -fl $src
        Run $RSYNC $dest.overlay/ $src/
        Run mount -o bind $dest.overlay $src
    else
        Run umount -fl $src
        Run $RSYNC --remove-source-files --delete-after $dest.overlay/ $src/
        Run umount -fl $dest.overlay
    fi
}

Flush ()
{
    local src=$1
    local dest=$2

    Umount $src $dest flush
}

MountMain ()
{
    local cmd=$1
    local dir
    local dest

    for dir in $DIRLIST
    do
        dest=$RAMDISK/${dir#/}

        if [ "$cmd" = "mount" ]; then
            Mount "$dir" "$dest"
        elif [ "$cmd" = "flush" ]; then
            Flush "$dir" "$dest"
        else
            Umount "$dir" "$dest"
        fi
    done

    touch "$LOCK"
}

StatusOverlays ()
{
    local dir

    for dir in $DIRLIST
    do
        IsMountOverlay $dir
    done
}

Status ()
{
    if IsMountRamdiskRoot ; then
        echo "$BIN: active tmpfs $RAMDISK"
    else
        echo "$BIN: deactive tmpfs $RAMDISK"
        return 1
    fi

    if [ -f "$LOCK" ]; then
        echo "$BIN: active process status $LOCK"
    else
        echo "$BIN: deactive process status. No $LOCK"
    fi

    local dir

    echo "$BIN: directories $DIRLIST"

    StatusOverlays | sed "s,^,$BIN: [mount] ,"

    return 0
}

RequireFeaturesOrDie ()
{
    if ! IsMountRamdiskRoot ; then
        Warn "$BIN: ERROR tmpfs $RAMDISK not mounted, check /etc/fstab. Aborted."
        exit 1
    fi

    if ! IsOverlayfs ; then
        Warn "$BIN: ERROR overlayfs not supported in current Kernel. Aborted."
        exit 1
    fi

    [ -x /usr/bin/rsync ] && return 0

    if ! which rsync > /dev/null 2>&1 ; then
        Die "$BIN: ERROR rsync(1) progam not in PATH. Aborted."
    fi
}

Main ()
{
    case "$1" in
        start)
            log_daemon_msg "Starting $BIN" "$BIN"

            if [ ! -d $RAMDISK ] ; then
                Warn "$BIN: ERROR no mount directory $RAMDISK for tmpfs. Aborted."
                return 1
            fi

            RequireFeaturesOrDie
            MountMain mount
            ;;
        restart | force-reload | reload | flush)
            RequireFeaturesOrDie
            MountMain flush
            :
            ;;
        stop)
            log_daemon_msg "Stopping $BIN" "$BIN"

            if [ ! -d $RAMDISK ] ; then
                return 1
            fi

            RequireFeaturesOrDie
            MountMain umount
            ;;
        status)
            RequireFeaturesOrDie
            Status
            ;;
        *)
            echo "Usage: $(basename $0) {start|stop|status|flush}"
            exit 2
            ;;
    esac
}

#test=1
#MountMain mount
#echo
#MountMain umount

Main "$@"

# End of file
